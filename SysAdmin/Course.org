#+title: Lfs 207 Course
#+date: <2024-12-17 Tue>
#+duedate: <2024-06-30 Sun>
#+STARTUP: inlineimages visual-line-mode

* Table Of Contents :toc_1:
- [[#course-introduction][Course Introduction]]
- [[#linux-filesystem-tree-layout][Linux Filesystem Tree Layout]]
- [[#user-environment][User Environment]]
- [[#user-account-management][User Account Management]]
- [[#group-management][Group Management]]
- [[#file-permissions-and-ownership][File Permissions and Ownership]]
- [[#package-management-systems][Package Management Systems]]
- [[#dpkg][dpkg]]
- [[#apt][APT]]
- [[#rpm][RPM]]
- [[#dnf-and-yum][DNF and YUM]]
- [[#zypper][zypper]]
- [[#git-fundamentals][GIT Fundamentals]]
- [[#processes][Processes]]
- [[#process-monitoring][Process Monitoring]]
- [[#memory-monitoring-usage-and-configuring-swap][Memory Monitoring, Usage and Configuring Swap]]
- [[#io-monitoring][I/O Monitoring]]
- [[#containers][Containers]]
- [[#linux-filesystems-and-the-vfs][Linux Filesystems and the VFS]]
- [[#disk-partitioning][Disk Partitioning]]
- [[#filesystem-features-attributes-creating-checking-usage-mounting][Filesystem Features: Attributes, Creating, Checking, Usage, Mounting]]
- [[#the-ext4-filesystem][The EXT4 Filesystem]]
- [[#logical-volume-management-lvm][Logical Volume Management (LVM)]]
- [[#kernel-services-and-configuration][Kernel Services and Configuration]]
- [[#kernel-modules][Kernel Modules]]
- [[#devices-and-udev][Devices and udev]]
- [[#network-addresses][Network Addresses]]
- [[#network-devices-and-configuration][Network Devices and Configuration]]
- [[#ldap][LDAP]]
- [[#firewalls][Firewalls]]
- [[#system-init-systemd-history-and-customization][System Init: systemd History and Customization]]
- [[#backup-and-recovery-methods][Backup and Recovery Methods]]
- [[#linux-security-modules][Linux Security Modules]]
- [[#system-rescue][System Rescue]]

* Course Introduction
** Course Information
To give your user access to sudo commands, one can use one of the following methods:
1. Adding a file with the user's name, in =/etc/sudoers.d/= sub directory with the content ~<username> ALL=(ALL) ALL~
2. Running the old command ~sudo chmod 440 /etc/sudoers.d/<username>~
   Note that some distros require 400 instead of 440

* Linux Filesystem Tree Layout
** Big Filesystem
Linux is just one big file system, unlike windows, which holds other stuff like registries.
Within this one large logical filesystem there may be more than one, even many, distinct filesystems, mounted at various points, which appear as subdirectories. These distinct filesystems are usually on different partitions, which can be on any number of devices, including those which are on a network.
Regardless of how things are joined together, it all just looks like one big filesystem; applications do not usually care at all about what physical device files actually reside on.
It used to be that different unix versions and linux distros had different ways of making this big tree, making the ecosystem quite hard to standardize
** Data Distinctions
There are two kinds of distinctions for data stored on the tree:
1. Shareable and Non Shareable
   Shareable data is that which can be shared between different hosts. Non-shareable data is that which must be specific to a particular host. Such as user files and lock files (.lck)
2. Variable and Static
   Static data include binaries, libraries, documentation, and anything that does not change without system administrator assistance. Variable data is anything that may change, even without a system administrator's help.
** FileSystem Hierarchy Standard
Administered originally by the Free Standards Group, and now by The Linux Foundation, specifies the main directories that need to be present, and describes their purposes. The [[https:refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf][Filesystem Hierarchy Standard document]] can be retrieved online.
By specifying a standard layout, the FHS simplifies predictions of file locations. While most Linux distributions respect the FHS, probably none of them follow it exactly, and the last official version might not take into account some new developments.
Distributions like to experiment and eventually some of the experiments become generally accepted.
*** root Directory
=/= is not =/root=
The root partition must contain all essential files required to boot the system and then mount all other filesystems. Thus, it needs utilities, configuration files, boot loader information, and other essential startup data. It must be adequate to:
+ Boot the system.​
+ Restore the system from system backups on external media such as tapes and other removable media or NAS etc.​
+ Recover and/or repair the system; an experienced maintainer must have the tools to diagnose and reconstruct a damaged system.
According to the FHS, no application or package should create new subdirectories of the root directory.
*** bin Directory
The =/bin= directory is very important because:

+ It contains executable programs and scripts needed by both system administrators and unprivileged users, which are required when no other filesystems have yet been mounted; for example, when booting into single user or recovery mode.
+ It may also contain executables which are used indirectly by scripts.
+ It may not include any subdirectories.
Required programs which must exist in the =/bin/= directory include: cat, chgrp, chmod, chown, cp, date, dd, df, dmesg, echo, false, hostname, kill etc

Command binaries that are deemed not essential enough to merit a place in the =/bin= directory go in =/usr/bin=. Programs required only by non-root users are placed in this category.

Some recent distributions have abandoned the strategy of separating =/bin= and =/usr/bin= (as well as =/sbin= and =/usr/sbin=) and just have one directory with symbolic links, thereby preserving a two directory view.
They view the time-honored concept of enabling the possibility of placing =/usr= on a separate partition to be mounted after boot as obsolete.
*** boot Directory
The =/boot= directory contains everything required for the boot process. The two files which are absolutely essential are:

+ ~vmlinuz~: The compressed Linux kernel
+ ~initramfs~: The initial RAM filesystem, which is mounted before the real root filesystem becomes available.

It stores data used before the kernel begins executing user-mode programs.
It also includes two files used for information and debugging:
- ~config~: Used to configure the kernel compilation.
- ~System.map~: Kernel symbol table, used for debugging.

The exact contents of =/boot= will vary by distribution and time
*** dev Directory
It contains special device files (aka device nodes) which represent devices built into or connected to the system. Such device files represent character (byte-stream) and block I/O devices; network devices do not have device nodes in Linux, and are instead referenced by name, such as eth1 or wlan0.
All modern Linux distributions use the udev system, which creates nodes in the /dev directory only as needed when devices are found. If you were to look at the /dev directory on an unmounted filesystem, you would find it empty.
[[img:/images/dev_node.png]]
On ancient systems (or embedded devices), it can be created by MAKEDEV or mknod at install or at any other time, as needed.
*** etc Directory
This directory contains machine-local configuration files and some startup scripts; there should be no executable binary programs.
Files and directories which the FHS requires to be found in this directory include:
    csh.login, exports, fstab, ftpusers, gateways, gettydefs, group, host.conf, hosts.allow, hosts.deny, hosts.equiv, hosts.lpd, inetd.conf, inittab
Some of these files are pretty irrelevant today, such as mtools.conf, which is used by floppy disks. Some will not be found any more, no matter what the FHS says (lol), due to software obsolescence.
+ **/etc/skel**
  Contains skeleton files used to populate newly created home directories.
+ **/etc/systemd**
  Contains or points to configuration scripts for starting, stopping, and controlling system services when using systemd.
+ **/etc/init.d**
  Contains startup and shutdown scripts for when using System V initialization.
*** lib Directory
These directories should contain only those libraries needed to execute the binaries in =/bin= and =/sbin=. These libraries are particularly important for booting the system and executing commands within the root filesystem.
Kernel modules (often device or filesystem drivers) are located under =/lib/modules/<kernel-version-number>=.

PAM (Pluggable Authentication Modules) files are stored in distribution-dependent locations such as =/lib64/security= or =/lib/x86_64-linux-gnu/security=.
Systems which support both 32-bit and 64-bit binaries need to keep both kinds of libraries on the system. On some distributions, there are separate directories for 32-bit libraries (=/lib=) and 64-bit libraries (=/lib64=).
*** media Directory
This directory was typically used to mount filesystems on removable media. These include CDs, DVDs, and USB drives, and even floppy disks.
Linux systems mount such media dynamically upon insertion, and udev creates directories and then mounts the removable filesystems there, with names that are set with udev rules specified in configuration files. Upon unmounting and removal, the directories used as mount points disappear.
If the media has more than one partition and filesystem, more than one entry will appear.

Current distros mount removable media at =/run/media= instead of =/media=
*** mnt Directory
This directory is provided so that the system administrator can temporarily mount a filesystem when needed. A common use is for network filesystems, including:
+ NFS
+ Samba
+ CIFS
+ AFS
Historically, =/mnt= was also used for the kinds of files which are now mounted under =/media= (or =/run/media=) in modern systems.
Generally speaking, this directory should not be used by installation programs. Another temporary directory not currently being used serves better.
Command:
#+begin_src bash
sudo mount c8:/ISO_IMAGES /mnt
#+end_src
*** opt Directory
This directory is designed for software packages that wish to keep all or most of their files in one isolated place, rather than scatter them all over the system in directories shared by other software. For example, if ~dolphy_app~ were the name of a package which resided under =/opt=, then all of its files should reside in directories under =/opt/dolphy_app=, including =/opt/dolphy_app/bin= for binaries and =/opt/dolphy_app/man= for any man pages.
This can make both installing and uninstalling software relatively easy, as everything is in one convenient isolated location in a predictable and structured manner. It also makes it easier for system administrators to determine the nature of each file within a package.

Note, however, if one uses packaging systems such as RPM and APT, as we shall discuss later, it is also easy to install and uninstall with a clear sense of file manifests and locations, without exhibiting such antisocial behavior.

In Linux, the =/opt= directory is often used by application providers with either proprietary software, or those who like to avoid complications of distribution variance.
For example, on one system the packages are in =/opt/brother=, =/opt/zoom= and =/opt/google= and the latter has subdirectories for chrome and earth.

The directories =/opt/bin=, =/opt/doc=, =/opt/include=, =/opt/info=, =/opt/lib=, and =/opt/man= are reserved for local system administrator use. Packages may provide files which are linked or copied to these reserved directories, but the packages must also be able to function without the programs being in these special directories. Most systems do not populate these directories.
*** proc Directory
This directory is the mount point for a pseudo-filesystem, where all information resides only in memory, not on disk. Like =/dev=, the =/proc= directory is empty on a non-running system.

The kernel exposes some important data structures through =/proc= entries. Additionally, each active process on the system has its own subdirectory that gives detailed information about the state of the process, the resources it is using, and its history.
The entries in =/proc= are often termed virtual files and have interesting qualities. While most are listed as zero bytes in size, when viewed, they can contain a large amount of information.
In addition, most of the time and date settings on virtual files reflect the current time and date, indicative of the fact they are constantly changing. In fact, the information in these files is obtained only when they are viewed; they are not being constantly or periodically updated.

Important pseudo-files, including =/proc/interrupts=, =/proc/meminfo=, =/proc/mounts=, and =/proc/partitions=, provide an up-to-the-moment glimpse of the system's hardware.
Others, like =/proc/filesystems= and the =/proc/sys/= directory, provide system configuration information and interfaces.
For organizational purposes, files containing information on a similar topic are grouped into virtual directories and sub-directories. For instance, =/proc/scsi/= contains information for all physical SCSI devices. Likewise, the process directories contain information about each running process on the system.
*** sys Directory
This directory is the mount point for the ~sysfs~ pseudo-filesystem where all information resides only in memory, not on disk. Like =/dev= and =/proc=, the =/sys= directory is empty on a non-running system. It contains information about devices and drivers, kernel modules, system configuration structures, etc.

~sysfs~ is used both to gather information about the system, and modify its behavior while running. In that sense, it resembles =/proc=, but it is younger than and has adhered to strict standards about what kind of entries it can contain.
For example, almost all pseudo-files in =/sys= contain only one line, or value; there are none of the long entries you can find in =/proc=.
*** root Directory
This directory (pronounced "slash-root") is the home directory for the root user.
The root account that owns this directory should only be used for actions which require superuser privilege. For those actions which can be done as a non-privileged user, use another account.
*** sbin Directory
This directory contains binaries essential for booting, restoring, recovering, and/or repairing in addition to those binaries in the =/bin= directory. They also must be able to mount other filesystems on =/usr=, =/home= and other locations if needed, once the root filesystem is known to be in good health during boot.

The following programs should be included in this directory (if their subsystems are installed):
fdisk, fsck, getty, halt, ifconfig, init, mkfs, mkswap, reboot, route, swapon, swapoff, update.

Recent distribution versions of RHEL, CentOS, Fedora, and Ubuntu have symbolically linked /sbin and /usr/sbin so they are actually the same.
*** srv Directory
=/srv= contains site-specific data which is served by this system.
This main purpose of specifying this is so that users may find the location of the data files for particular service, and so that services which require a single tree for readonly data, writable data and scripts (such as cgi scripts) can be reasonably placed.
The methodology used to name subdirectories of =/srv= is unspecified as there is currently no consensus on how this should be done. One method for structuring data under =/srv= is by protocol, e.g. ~ftp, rsync, www, and cvs.~

Some system administrators (and distributions) swear by the use of the =/srv= directory; others ignore it. There is often confusion about what is best to go in =/var=, as opposed to =/srv=.
On Linux distributions such as Ubuntu and Red Hat-based ones, =/srv= is empty by default.
*** tmp Directory
This directory is used to store temporary files, and can be accessed by any user or application. However, the files on =/tmp= cannot be depended on to stay around for a long time:

- Some distributions run automated cron jobs, which remove any files older than 10 days typically, unless the purge scripts have been modified to exclude them.
- Some distributions remove the contents of =/tmp= with every reboot. This has been the Ubuntu policy.
- Some modern distributions utilize a virtual filesystem, using the =/tmp= directory only as a mount point for a ram disk using the tmpfs filesystem. This is the default policy on Fedora systems. When the system reboots, all information is thereby lost; =/tmp= is indeed temporary!

In the last case, you must avoid creating large files on =/tmp=; they will actually *occupy space in memory* rather than disk, and it is easy to harm or crash the system through memory exhaustion. While the guideline is for applications to avoid putting large files in =/tmp=, there are plenty of applications that violate this policy and which make large temporary files in =/tmp=. Even if it is possible to put them somewhere else (perhaps by specifying an environment variable), many users are not aware of how to configure this and all users have access to =/tmp=.

This policy can be canceled on systems using systemd, such as Fedora, by issuing the command:
#+begin_src bash
 sudo systemctl mask tmp.mount
#+end_src
followed by a system reboot.
*** usr Directory
The =/usr= directory can be thought of as a secondary hierarchy. It is used for files which are not needed for system booting. Indeed, =/usr= need not reside in the same partition as the root directory, and can be shared among hosts using the same system architecture across a network.
| Directory    | Purpose                                           |
| ---------    | -------                                           |
| /usr/bin     | Non-essential command binaries                    |
| /usr/etc     | Non-essential configuration files (usually empty) |
| /usr/games   | Game data                                         |
| /usr/include | Header files used to compile applications         |
| /usr/lib     | Library files                                     |
| /usr/lib64   | Library files for 64-bit                          |
| /usr/local   | Third-level hierarchy (for machine local files)   |
| /usr/sbin    | Non-essential system binaries                     |
| /usr/share   | Read-only architecture-independent files          |
| /usr/src     | Source code and headers for the Linux kernel      |
| /usr/tmp     | Secondary temporary directory                     |
*** var Directory
This directory contains variable (or volatile) data files that change frequently during system operation. These include:

- Log files
- Spool directories and files
- Administrative data files
- Transient and temporary files, such as cache contents.
Obviously, =/var= cannot be mounted as a read-only filesystem.
For security reasons, it is often considered a good idea to mount =/var= as a separate filesystem. Furthermore, if the directory gets filled up, it should not lock up the system.
=/var/log= is where most of the log files are located, and =/var/spool= is where local files for processes such as mail, printing, and cron jobs are stored while awaiting action.
| Subdirectory | Purpose                                                                        |
| ------------ | -------                                                                        |
| /var/ftp     | Used for ftp server base                                                       |
| /var/lib     | Persistent data modified by programs as they run                               |
| /var/lock    | Lock files used to control simultaneous access to resources                    |
| /var/log     | Log files                                                                      |
| /var/mail    | User mailboxes                                                                 |
| /var/run     | Information about the running system since the last boot                       |
| /var/spool   | Tasks spooled or waiting to be processed, such as print queues                 |
| /var/tmp     | Temporary files to be preserved across system reboot. Sometimes linked to /tmp |
| /var/www     | Root for website hierarchies                                                   |
*** run Directory
The purpose of /run is to store transient files: those that contain runtime information, which may need to be written early in system startup, and which do not need to be preserved when rebooting.

Generally, =/run= is implemented as an empty mount point, with a tmpfs ram disk (like =/dev/shm=) mounted there at runtime. Thus, this is a pseudo filesystem existing only in memory.
Some existing locations, such as =/var/run= and =/var/lock=, will be now just symbolic links to directories under =/run=. Other locations, depending on distribution taste, may also just point to locations under =/run=.

* User Environment
** Environmment Variables
The environment variables can be listed with =env=, =set= or =printenv=, there are more than you think
Many applications and programming languages use them and expect them, failing if they are not present. Linux uses them for many things, setting them up when the system starts. You can create and manipulate your own for your own purposes.
You can associate a name with a variable value: ~HOME~, ~HOST~, ~PATH~, etc.

+ They can be listed in different formats with various commands:
  #+begin_src bash
  env
  export
  set
  #+END_SRC
+ All variables are prefixed with $ when referenced:
  #+begin_src bash
  echo PATH = $PATH
  #+END_SRC
+ Except when they are being defined, remember, no spaces between the equal signs!
  #+begin_src bash
  MYCOLOR=blue
  #+END_SRC
+ Examples
  #+begin_src bash
  env | head -2
  export | head -2
  echo $PATH
  #+END_SRC
** Important Environment variables
Use ~echo $ENVVAR~ to get outputs
+ HOME
  User's home directory
  Lets you reach the home directory with the cd command
+ PATH
  Ordered list of directories to search for programs to run
  Directories are separated by colons
+ PS1
  Command line prompt, easy to customize
+ SHELL
  User's default shell (bash, csh, etc.)
+ EDITOR
  User's default editor (emacs, vi, etc)
** Setting Env Vars
You can list a specific variable.
#+begin_src bash
echo $SHELL
#+end_src
You can set a new variable value with:
#+begin_src bash
VARIABLE=value
#+end_src
You can add a new variable permanently:
+ Edit ~/.bashrc to include VARIABLE=value
+ Start a new shell or logout/login
** Exporting Env Vars
By default, variables created within a script are only available to the current shell. Child processes (sub-shells) will not have access to the content of this variable. In order for variables to be visible to child processes, they need to be exported using the export command.
Exporting a variable can be done in one step:
#+begin_src bash
export VAR=value
#+end_src
or in two steps:
#+begin_src bash
VAR=value ; export VAR
#+end_src
Keep in mind that the child process is allowed to modify exported variables, but the change in this case will not propagate back to the parent shell since exported variables are not shared, but only copied.
** User Env
The shell stores history in ~/.bash_history:
+ Location of the history file: HISTFILE
+ Maximum number of lines in the history file: HISTFILESIZE
+ Maximum number of lines of history list in the current session: HISTSIZE
** Recalling, Editing Previous Commands
With the arrow keys, you are essentially moving up and down your history list - most recently executed command first. ~!!~ (often pronounced as “bang-bang”) executes the previous command.
~CTRL-R~ is used to search through history
** Prev Command from history
All history substitutions start with ~!~.
+ To start a history substitution: ~!~
+ To refer to the last argument in a line: ~!$~
+ To refer to the n-th command line: ~!n~
+ To refer to the most recent command starting with ~!string~
** Alias
Aliases permit custom definitions. Typing alias with no arguments gives the list of defined aliases. unalias gets rid of an alias.
You can create customized commands by creating aliases:
#+begin_src bash
alias name=command
#+end_src
Note that there are no spaces around the = (equal) sign.
To make an alias persistent, you should edit =~/.bashrc=.
You can use the following command to get rid of an alias:
#+begin_src bash
unalias name
#+end_src
You can list all currently active aliases with this command:
#+begin_src bash
alias
#+end_src
* User Account Management
** Attributes of a User Account
Each user on the system has a corresponding line in the /etc/passwd file that describes their basic account attributes
The attributes of a user account are:
+ User name
  This is the unique name assigned to each user.
+ User password
  This is the password assigned to each user.
+ User identification number (UID)
  This is a unique number assigned to the user account. The UID is used by the system for a variety of purposes, including a determination of user privileges and activity tracking.
+ Group identification number (GID)
  This indicates the primary, principal, or default group of the user.
+ Comment or GECOS information
  A defined method to use the comment field for contact information (full name, email, office, contact number). Do not worry about what GECOS means, it is a very old term.
+ Home directory
  For most users, this is a unique directory that offers a working area for the user. Normally, this directory is owned by the user, and except for root, will be found on the system somewhere under =/home=.
+ Login shell
  Normally, this is a shell program such as ~/bin/bash~ or ~/bin/csh~. Sometimes, however, an alternative program is referenced here for special cases. In general, this field will accept any executable.
** Startup Files
Every time a new shell (either a command window or a script that is run) begins executing, there are files included that contain elements employed to ensure proper functioning.
This may include:
+ Defining relevant environment variables that are used by many programs and scripts (including $PATH)
+ Defining aliases that are used as shorthand to specify commands and options
+ Defining functions that can be used in subsequent scripts
There are usually system-wide global initializing files found in =/etc= that are used by all users before individualized files are used.
The files in the user home directory override global settings.
** Advantages of Startup Files
Without the startup (initialization) file processing, each time a command or program is run there may be a lot of setup work to ensure proper functioning.
Many programs evaluate certain environment variables are set when they begin to execute, and then make use of them to control functioning.

For example, any program which needs to modify text files interactively will see how EDITOR is set, perhaps to vim, emacs, or nano (whichever editor the user prefers to use).
To summarize, some of the advantages of using startup files are:
+ Customizing the user's prompt
+ Setting the user's terminal type
+ Setting command line shortcuts and aliases
+ Setting the default text editor
+ Etc.
** Startup Files Order
When you login to Linux, =/etc/profile= is always read and evaluated. Next, the following files are searched for in this order:
+ =~/.bash_profile= - login shells configuration
+ =~/.bash_login= - login initialization
= =~/.profile= - overrides /etc/profile

After finding the first file it comes to, the Linux login shell will evaluate that one startup file and ignore all the rest.
While this may sound redundant, various Linux distributions tend to use different startup files.

Every time you create a sub-shell, but aren’t logging in, only =~/.bashrc= is read and evaluated. While it is not read and evaluated with a login shell, most distributions and users will call =~/.bashrc= from within one of the three user-owned startup files; so, in reality, =~/.bashrc= is used for login shells.

Thus the vast majority of your customizations should go into =~/.bashrc=.
** Creating User Accounts with useradd
useradd allows for default operation with the following command:
#+begin_src bash
sudo useradd bjmoose
#+end_src
And causes the following steps to execute:
+ The next available UID greater than ~UID_MIN~ (specified in =/etc/login.defs=) by default is assigned as bjmoose’s UID
+ A group called bjmoose with a ~GID=UID~ is also created and assigned as bjmoose’s primary group
+ A home directory =/home/bjmoose= is created and owned by bjmoose
+ bjmoose’s login shell will be =/bin/bash=
+ The contents of =/etc/skel= is copied to =/home/bjmoose=. By default, =/etc/skel= includes startup files for bash and for the X Window system
+ An entry of ~!!~ is placed in the password field of the =/etc/shadow= file for bjmoose’s entry, thus requiring the administrator to assign a password for the account to be usable.

The defaults can easily be overruled by using options to useradd as in:
#+begin_src bash
sudo useradd -s /bin/csh -m -k /etc/skel -c "Bullwinkle J Moose" bjmoose
#+end_src
Where explicit non-default values have been given for some of the user attributes.
** Modifying and Deleting User Accounts
The root user can delete user accounts with ~userdel~:
#+begin_src bash
sudo userdel rjsquirrel
#+end_src
All references to the user *rjsquirrel* will be erased from =/etc/passwd=, =/etc/shadow=, and =/etc/group=.
While this removes the account, it does not delete the home directory (usually =/home/rjsquirrel=) in case the account may be re-established later. If the ~-r~ option is given to ~userdel~, the home directory will also be obliterated.
However, all other files on the system owned by the removed user will remain.

~usermod~ can be used to change characteristics of a user account such as group memberships, home directory, login name, password, default shell, user id, etc. Usage is pretty straightforward.
Note that ~usermod~ will take care of any modifications to files in the =/etc= directory as necessary.
The command:
#+begin_src bash
sudo usermod -L bjmoose
#+end_src
will lock the user so they cannot login. More commands can be looked at using ~sudo usermod --help~
** Locked Accounts
Linux ships with some locked accounts which means they can run programs, but can never login to the system and have no valid password associated with them.
For example =/etc/passwd= has entries like:
#+begin_src bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
#+end_src
The nologin shell returns the following if a locked user tries to login to the system: *This account is currently not available*
Or whatever message may be stored in =/etc/nologin.txt=.
Such locked accounts are created for special purposes, either by system services or applications; if you scan =/etc/passwd= for users with the nologin shell you can see who they are on your system.
It is also possible to lock the account of a particular user as in the following command:
#+begin_src bash
sudo usermod -L bjmoose
#+end_src
Which means the account stays on the system but logging in is impossible. Unlocking can be done with the ~-U~ option.
A customary practice is to lock a user’s account whenever they leave the organization or is on an extended leave of absence.
Another way to lock an account is to use chage to change the expiration date of an account, as in the following command:
#+begin_src bash
sudo chage -E 2001-09-11 rjsquirrel
#+end_src
The actual date is irrelevant as long as it is in the past.
Locked accounts have no valid password, and are usually represented by "!!" in =/etc/shadow=
** User IDs and /etc/passwd
The convention most Linux distributions have used is that any account with a UID less than 1000 is considered special and belongs to the system; normal user accounts start at 1000.
The actual value is defined as UID_MIN and is defined in =/etc/login.defs=.
Historically, Red Hat-derived distributions used ~UID_MIN=500~, not 1000, but beginning with ~RHEL 7~, the more common value of ~1000~ was adopted.

If a UID is not specified when using useradd, the system will incrementally assign use IDs starting at ~UID_MIN~.

Additionally, each user gets a Primary Group ID which by default is the same number as the UID. These are sometimes called User Private Groups (UPG).
=/etc/passwd= file contains one record (one line) for each user, each of which is a colon ( : ) separated list of fields:

+ username: user’s unique name
+ password: either the hashed password (if =/etc/shadow= is not used) or a place holder (”x” when =/etc/shadow= is used)
+ UID: user identification number
+ GID: primary group identification number for the user
+ comment: comment area, usually the user’s real name
+ home: directory pathname for the user’s home directory
+ shell: absolutely qualified name of the shell to invoke at login

It is bad practice to edit =/etc/passwd=, =/etc/group= or =/etc/shadow= directly; use appropriate utilities such as ~usermod~, or for advanced users - the slightly safer tools ~vipw/vigr~.
** Why Use /etc/shadow?
The default permissions of =/etc/passwd= are ~644 (-rw-r--r--)~; anyone can read the file. This is unfortunately necessary because system programs and user applications need to read the information contained in the file. These system programs do not run as the user root and, in any event, only root may change the file.

Of particular concern are the hashed passwords themselves. If they appear in =/etc/passwd=, anyone may make a copy of the hashed passwords and then make use of utilities such as Crack and John the Ripper to guess the original cleartext passwords given the hashed password. This is a security risk!
=/etc/shadow= has permission settings of ~400 (-r--------)~, which means that only root can access this file. This makes it more difficult for someone to collect the hashed passwords.

Unless there is a compelling good reason not to, you should use the =/etc/shadow= file.
** /etc/shadow Format
=/etc/shadow= contains one record (one line) for each user, as in:
#+begin_src bash
daemon:*:16141:0:99999:7:::
.....
beav:$6$iCZyCnBJH9rmq7P.$RYNm10Jg3wrhAtUnahBZ/mTMg.RzQE6iBXyqaXHvxxbK\
   TYqj.d9wpoQFuRp7fPEE3hMK3W2gcIYhiXa9MIA9w1:16316:0:99999:7:::
#+end_src

Each record contains fields separated by colons ( : ):
+ username: unique user name
+ password: the hashed (sha512) value of the password
+ lastchange: days since Jan 1, 1970 that password was last changed
+ mindays: minimum days before password can be changed
+ maxdays: maximum days after which password must be changed
+ warn: days before password expires that the user is warned
+ grace: days after password expires that account is disabled
+ expire: date that account is/will be disabled
+ reserved: reserved field

The username in each record must match exactly that found in =/etc/passwd=, and also must appear in the identical order. All dates are stored as the number of days since Jan. 1, 1970 (_the epoch date_).

The password hash is the string ~$6$~ followed by an eight character salt value, which is then followed by a $ and an 88 character (~sha512~) password hash.
** Password Management

Passwords can be changed with passwd.

Users can change their own password. Root can change any user password.

By default, the password choice is examined by ~pam_cracklib.so~, which furthers making good password choices.
A normal user changing their password would type the following command:
#+begin_src bash
passwd
#+end_src
Note that when root changes a user’s password, root is not prompted for the current password.
Command:
#+begin_src bash
sudo passwd rjsquirrel
#+end_src
Note that normal users will not be allowed to set bad passwords, such as ones that are too short, or based on dictionary words. However, root is allowed to do so.
** Password Aging (chage)
It is generally considered important to change passwords periodically. This limits the amount of time a cracked password can be useful to an intruder and also can be used to lock unused accounts.
The downside is users can find this policy annoying and wind up writing down their ever-changing passwords and thus making them easier to steal.
The utility that manages this is chage:
#+begin_src bash
chage [-m mindays] [-M maxdays] [-d lastday] [-I inactive] [-E expiredate] [-W warndays] user
#+end_src
Only the root user can use chage. The one exception to this is that any user can run with the -l option to determine when their password or account is due to expire.
To force a user to change their password at their next login, you can run the following command:
#+begin_src bash
sudo chage -d 0 USERNAME
#+end_src
Examples of chage:
#+begin_src bash
sudo chage -l beaver
sudo chage -m 14 -M 30 wally
sudo chage -E 2012-4-1 eddie
sudo chage -d 0 june
#+end_src
** The root Account
root has access to everything and can do everything; this is a very powerful account.

~sudo~ allows regular user accounts to have root privileges on a temporary basis. ~sudo~ can be configured to allow only certain accounts to have this ability and for certain accounts to only have elevated privileges for certain commands. ~sudo~ configuration is done in =/etc/sudoers= and =/etc/sudoers.d=. See ~man sudo~ for more details.
~su~ (pronounced ess-you and means switch or substitute user) creates a sub-shell environment that allows the user elevated privileges until they exit that shell.
All commands executed in that sub-shell are executed with the elevated privileges of the root user.

The root account should only be used for administrative purposes when absolutely necessary and never used as a regular account. Mistakes can be very costly, both for integrity and stability, and system security.

By default, root logins through the network are generally prohibited for security reasons.
One can permit Secure Shell logins using ~ssh~, which is configured with =/etc/ssh/sshd_config=, and ~PAM~ (Pluggable Authentication Modules), through the =pam_securetty.so= module and the associated =/etc/securetty= file. Root login is permitted only from the devices listed in =/etc/securetty=.

It is generally recommended that all root access be through ~su~ or ~sudo~ (causing an audit trail of all root access through sudo).
Note some distributions (such as Ubuntu), by default actually prohibit logging in directly to the root account.
~PAM~ can also be used to restrict which users are allowed to ~su~ into root. It might also be worth it to configure ~auditd~ to log all commands executed as root.
** SSH
One often needs to login through the network into a remote system, or carry out commands on a remote system, either with the same username or another.
Or one needs to transfer files to and from a remote machine (/using scp/). In either case, one wants to do this securely, free from interception.

SSH (Secure SHell) exists for this purpose. It uses encryption based on strong algorithms.
Assuming the proper ssh packages are installed on a system, one needs no further setup to begin using ssh. To sign onto a remote system, you can use the following command:
#+begin_src bash
ssh root@farflung.com
ssh -l root farflung.com
#+end_src

To copy files from one system to another, you can do the following:
#+begin_src bash
scp file.txt farflung.com:/tmp
scp file.tex student@farflung.com/home/student
scp -r some_dir farflung.com:/tmp/some_dir
#+end_src
To run a command on multiple systems simultaneously, you can use the following command:
#+begin_src bash
for machines in node1 node2 node3
  do
      (ssh $machines some_command &)
done
#+end_src
You can use the ~pssh~ (Parallel SSH) utility to execute a command on multiple systems in one fell stroke as in:
#+begin_src bash
pssh -viH machine1 machine2 machine3 do_something
#+end_src
You may need to read the ~man~ page for ~pssh~ to figure out all its options and how to deal with passwords.
** ssh Configuration Files
One can configure SSH further to expedite its use, in particular to permit logging in without a password. User-specific configuration files are created under every user’s home directory in the hidden .ssh directory:

+ id_rsa: the user's private key
+ id_rsa.pub: the user's public key
+ authorized_keys: public keys that are permitted to log in
+ known_hosts: hosts from which logins have been allowed in the past
+ config: file for specifying various options
First a user has to generate their private and public encryption keys with ~ssh-keygen~

The private key must never ever be shared with anyone. The public key, however, should be given to any machine with which you want to permit password-less access.

Note that ~authorized_keys~ contains public keys that are allowed to login as you on this machine.
~known_hosts~ is gradually built up as ssh accesses occur. If the system detects changes in the users who are trying to log in through ssh, it will warn you of them and afford the opportunity to deny access.

Check out these [[https://infosec.mozilla.org/guidelines/openssh][online OpenSSH]] guidelines for a list of updated best practices on ssh configuration parameters.
** SSH Configuration File Precedence

The order the configuration files are processed is as follows:
1. ~/.ssh/config
2. /etc/ssh/ssh_config

The precedence of the files and the contents is first match used.
#+begin_src bash
/home/student/.ssh/config

Host apple
         HostName 192.168.0.196
         User student
         Port 4242
         IdentityFile /home/student/.ssh/custom

Host aws
         Hostname ec2-34-238-135-25.compute-1.amazonaws.com
         User ubuntu
         IdentityFile /home/student/.ssh/cloud1.pem
         ForwardX11 no
         PasswordAuthentication no Host *
#+end_src

In the above =~/.ssh/config= specific configuration information is listed for the hosts ~apple~ and ~aws~.
If neither of these match, then the generic parameters would apply. This configuration has no generic parameters. The command usage would be:
#+begin_src bash
ssh apple
echo "or"
ssh aws
#+end_src
** SSH on a Cloud System
SSH on a cloud system works the same, with some automation applied.
+ The ssh keys are generated for the default user during cloud system creation
+ The public key is copied into the default user’s authorized_keys file
+ An option to copy the public and private to your local system is presented
+ Password-based authentication is generally not supported for users on cloud systems
It is not uncommon to misplace public keys on remote systems. Recreating a public can be done with ~ssh-keygen~.
#+begin_src bash
ssh-keygen -y -f ̃/.ssh/id_ed25519 > ̃/.ssh/id_ed25519.pub
#+end_src
Can be used to generate a new public key using the private one
** Remote Graphical Login
You can login into remote machine with full graphical desktop.
+ Often use VNC (Virtual Network Computing)
+ Common implementation is tigervnc

This can be as simple as running the following command on a local machine:
#+begin_src bash
vncviewer -via server student@some_machine localhost:2
#+end_src
You may have to play with numbers other than 2 (1, 3, 4, ...) depending on what you are running at the moment and how your machine is configured.
To view from a remote machine it is just slightly different. You can do:
#+begin_src bash
vncviewer -via student@some_machine localhost:2
#+end_src
If you get a rather strange message about having to authenticate because of "color profile" and no passwords work, you have to kill the colord daemon on the server machine, as in:
#+begin_src bash
sudo systemctl stop colord
#+end_src
This is a bug (not a feature) and will only appear in some distributions and some systems for unclear reasons.
* Group Management
* File Permissions and Ownership
** Overview
** File Permissions and Ownership

* Package Management Systems
** Overview
** Package Management Systems

* dpkg
** Overview
** dpkg

* APT
** Overview
** APT

* RPM
** Overview
** RPM

* DNF and YUM
** Overview
** dnf and yum

* zypper
** Overview
** zypper

* GIT Fundamentals
** Overview
** Introduction to GIT

* Processes
** Overview
** Processes

* Process Monitoring
** Overview
** Process Monitoring

* Memory Monitoring, Usage and Configuring Swap
** Overview
** Memory Monitoring, Usage and Configuring Swap

* I/O Monitoring
** Overview
** I/O Monitoring and Tuning

* Containers
** Overvie
** Container
* Linux Filesystems and the VFS
** Overview
** Linux Filesystems and the VFS

* Disk Partitioning
** Overview
** Disk Partitioning

* Filesystem Features: Attributes, Creating, Checking, Usage, Mounting
** Overview
** Filesystem Features: Attributes, Creating, Checking, Usage, Mounting

* The EXT4 Filesystem
** Overview
** The Ext4 Filesystem

* Logical Volume Management (LVM)
** Overview
** Logical Volume Management

* Kernel Services and Configuration
** Overview
** Kernel Services and Configuration

* Kernel Modules
** Overview
** Kernel Modules

* Devices and udev
** Overview
** Devices and udev

* Network Addresses
** Overview
** Network Addresses

* Network Devices and Configuration
** Overview
** Network Devices and Configuration

* LDAP
** Overview
** LDAP

* Firewalls
** Overview
** Firewalls

* System Init: systemd History and Customization
** Overview
** System Init: systemd, SystemV and Upstart

* Backup and Recovery Methods
** Overview
** Backup and Recovery Methods

* Linux Security Modules
** Overview
** Linux Security Modules

* System Rescue
** Overview
** System Rescue

